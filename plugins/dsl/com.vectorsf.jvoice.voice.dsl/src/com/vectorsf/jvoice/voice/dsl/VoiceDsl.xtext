grammar com.isb.bks.ivr.voice.dsl.VoiceDsl with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations
import "http://www.isb.com/bks/ivr/voice/dsl/VoiceDsl/1.0"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes


VoiceDsl:
	InputDsl
	| MenuDsl
	| PromptDsl
	| RecordDsl
	| TransferDsl
    ;

PromptDsl:
	'outputname'  name = ID 
       ((configuration = Configuration)& 
       	((variables = Variables)?)& 
	    (conditions += Condition*))
  	     audios=Audios	
;

MenuDsl:
	'menuname'  name = ID
	   ((configuration = Configuration)& 
        (grammars = Grammars)&
	    (properties += Property*)&
	    ((variables = Variables)?)& 
	    (conditions += Condition*))
	     audios=Audios
  	     outputs=Outputs
;

InputDsl:
	'inputname'  name = ID
      ((configuration = Configuration)& 
 	   (grammars = Grammars)&
	   (properties += Property*)&
	   ((variables = Variables)?)&
	   (conditions += Condition*))
  	    audios=Audios	
;

RecordDsl:
	'recordname' name = ID 'filename' fileName = STRING
      ((configuration = Configuration)& 
	   (properties += Property*)&
	   ((variables = Variables)?)&
	   (conditions += Condition*))
  	    audios=Audios	
;

TransferDsl:
	'transfername' name = ID 'typeTransfer' typeTransfer = TypeTransfer
	   (('destination' destination = STRING )&
		('audioTransfer' audioTransfer = STRING )?& 
		('maxTime' maxTime = STRING )?&
		('timeout' timeout = STRING )?)
       ((properties += Property*)& 
       	((variables = Variables)?)& 
	    (conditions += Condition*))
  	     audios=Audios	
;
	  
Variables:
	{Variables}
	'variables' '{'
	  variable += Variable*
	 '}'
;

Variable:
    name=ID '=' externalVar = ID '.' method = ID '()' ';'
;

Grammars:
	{Grammars}
	'grammars' '{'
	       grammatics += Grammar*
	    '}'
;

Audios: 
	'audios' '{' 
	('main' ':' (
			mainAudios += ConditionalAudio+))? &
	('match' ':' (
			matchAudios += ConditionalAudio+))? &
	('nomatch' ':' (
		    noMatchAudios += ConditionalAudio+))? &
	('noinput' ':' (
		    noInputAudios += ConditionalAudio+))? 
		     
    '}'
;

Configuration:
	{Configuration}
	'configuration' '{'
	  configValue += ConfigValue*
	 '}'
;

ConfigValue:
	name = ID value=ConfigValueValue
;

ConfigValueValue:
	INT ('ms'|'s')?| FLOAT | 'true' | 'false' 
;

Grammar:
	mode = ('voice'|'dtmf'|'voicedtmf') expr ?= 'expr'? src = STRING
;

Property:
	'property' name = QualifiedName value = STRING
;

Condition:
	{Condition}
	'condition' name = ID condition = INT 
;

Outputs:
	'outputs' '{' 
  		  output+=Output+
	 '}'
;

Output:
	 name = ID ':' outputValue+=OutputValue (',' outputValue+=OutputValue)*
;

OutputValue:
	value=STRING | value='*'
;

SimpleAudio returns Audio:
	{Audio}
	'say' (('src' src=STRING)?
		(('wording' tts=STRING ) |
			('as' (interpretation=Interpretation) ('(' format=STRING ')')?  tts=STRING)
		)?
	)
;

enum Interpretation:
	number | boolean | currency | date | digits | phone | time
;

enum TypeTransfer:
	blind | consultation | bridge
;

ConditionalAudio returns Audio:
	{ConditionalAudio}
	'when' '('  condit=STRING ')'  '{' (simpleAudios+=SimpleAudio)+ '}'		                                      
    |SimpleAudio
 ;
 
 terminal FLOAT :
   (INT '.' INT)
;

Type :
  {Type} annotations+=XAnnotation*
  (
  	{Class.annotationInfo = current}
    'variables' 
    '{'
    (members+=Member)*
    '}'
  )
;

Member :
	{Member}
   annotations+=XAnnotation*
   (    
  	{Field.annotationInfo = current}
    ((type=JvmTypeReference) name=ID) ('=' initialValue=XExpression)? ';'?
    
    |
     {Function.annotationInfo = current}
    ('public' =>(returnType=JvmTypeReference name=ID ))   (expression=XBlockExpression)
   
) ;


