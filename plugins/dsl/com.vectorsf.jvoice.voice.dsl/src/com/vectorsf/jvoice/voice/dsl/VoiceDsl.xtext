grammar com.isb.bks.ivr.voice.dsl.VoiceDsl with org.eclipse.xtext.xbase.annotations.XbaseWithAnnotations
import "http://www.isb.com/bks/ivr/voice/dsl/VoiceDsl/1.0"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as jvmTypes


VoiceDsl:
	InputDsl
	| MenuDsl
	| PromptDsl
    |(  (types+=Type)*)
;

PromptDsl:
	('outputname'  name = ID 
       ((properties += Property*)& 
       	((variables = Variables)?)& 
	    (conditions += Condition*))
  	     audios=Audios	
	   ) 
;

MenuDsl:
	('menuname'  name = ID
	   ((configuration = Configuration)& 
        (grammars = Grammars)&
	    (properties += Property*)&
	    ((variables = Variables)?)& 
	    (conditions += Condition*))&
	     (audios=Audios)&
  	     outputs=Outputs
	   ) 
;

InputDsl:
	('inputname'  name = ID           
      ((configuration = Configuration)& 
 	   (grammars = Grammars)&
	   (properties += Property*)&
	   ((variables = Variables)?)&
	   (conditions += Condition*))
  	    audios=Audios	
	  ) 
;
	
	  
Variables:
	{Variables}
	'variables' '{'
	  variable += Variable*
	 '}'
;

Variable:
    name=ID '=' externalVar = ID '.' method = ID '()' ';'
;

Grammars:
	{Grammars}
	'grammars' '{'
	       grammatics += Grammar*
	    '}'
;

Audios:
	'audios' '{' 
	('main' ':' (
			mainAudios += ConditionalAudio+))? &
	('match' ':' (
			matchAudios += ConditionalAudio+))? &
	('nomatch' ':' (
		    noMatchAudios += ConditionalAudio+))? &
	('noinput' ':' (
		    noInputAudios += ConditionalAudio+))? 
		     
    '}'
;

Configuration:
	{Configuration}
	'configuration' '{'
	  configValue += ConfigValue*
	 '}'
;

ConfigValue:
	name = ID value=ConfigValueValue
;

ConfigValueValue:
	INT ('ms')?| FLOAT | 'true' | 'false' 
;

Grammar:
	mode = ('voice'|'dtmf'|'voicedtmf') expr ?= 'expr'? src = STRING
;

Property:
	'property' name = QualifiedName value = STRING
;

Condition:
	{Condition}
	'condition' name = ID condition = INT 
;

Outputs:
	'outputs' '{' 
  		  output+=Output+
	 '}'
;

Output:
	 name = ID ':' outputValue+=OutputValue (',' outputValue+=OutputValue)*
;

OutputValue:
	value=STRING | value='*'
;

SimpleAudio returns Audio:
	{Audio}
	'say' (('src' src=STRING)?
		(('wording' tts=STRING ) |
			('as' (interpretation=Interpretation) ('(' format=STRING ')')?  tts=STRING)
		)?
	)
;

enum Interpretation:
	number | boolean | currency | date | digits | phone | time
;	

ConditionalAudio returns Audio:
	{ConditionalAudio}
	'when' '('  condit=STRING ')'  '{' (simpleA=SimpleAudio)+ '}'		                                      
    |SimpleAudio
 ;
 
 terminal FLOAT :
   (INT '.' INT)
;

Type :
  {Type} annotations+=XAnnotation*
  (
  	{Class.annotationInfo = current}
    'variables' 
    '{'
    (members+=Member)*
    '}'
  )
;

Member :
	{Member}
   annotations+=XAnnotation*
   (    
  	{Field.annotationInfo = current}
    ((type=JvmTypeReference) name=ID) ('=' initialValue=XExpression)? ';'?
    
    |
     {Function.annotationInfo = current}
    ('public' =>(returnType=JvmTypeReference name=ID ))   (expression=XBlockExpression)
   
) ;


